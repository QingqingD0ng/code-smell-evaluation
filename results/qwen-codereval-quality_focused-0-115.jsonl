{"dataset": "coderEval", "task_id": "62e60f43d76274f8a4026e28", "original_prompt": "def hydrate_time(nanoseconds, tz=None):\n\t\"\"\"\n\tConvert nanoseconds to a time in fixed format.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nfrom datetime import datetime, timezone\n\ndef hydrate_time(nanoseconds, tz=None):\n    seconds, nanos = divmod(nanoseconds, 1_000_000_000)\n    dt = datetime.fromtimestamp(seconds, tz or timezone.utc) + timedelta(microseconds=nanos // 1000)\n    return dt.strftime('%Y-%m-%d %H:%M:%S.%f%z')\n```"}}}
{"dataset": "coderEval", "task_id": "62e60f3bd76274f8a4026e10", "original_prompt": "def dehydrate_timedelta(value):\n\t\"\"\"\n\tUse the value in timedelta to generate the Structure class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Structure:\n    days: int\n    seconds: int\n    microseconds: int\n\ndef dehydrate_timedelta(value):\n    return Structure(days=value.days, seconds=value.seconds, microseconds=value.microseconds)\n```"}}}
{"dataset": "coderEval", "task_id": "62e60f37d76274f8a4026dfd", "original_prompt": "def dehydrate_time(value):\n\t\"\"\"\n\tUse ticks in the Time class to generate the Structure class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef dehydrate_time(value):\n    return value.ticks\n```"}}}
{"dataset": "coderEval", "task_id": "62e60f33d76274f8a4026de9", "original_prompt": "def dehydrate_point(value):\n\t\"\"\"\n\tThe structure class is generated based on the value length.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef dehydrate_point(value):\n    structure_class = {\n        1: 'Single',\n        2: 'Pair',\n        3: 'Triple',\n        4: 'Quadruple'\n    }.get(len(value), 'Unknown')\n    return structure_class\n```"}}}
{"dataset": "coderEval", "task_id": "62e60ed4d76274f8a4026da0", "original_prompt": "def keys(self):\n\t\"\"\"\n\tReturns the __keys property of a class as a List\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef keys(self):\n    return list(self.__keys)\n```"}}}
{"dataset": "coderEval", "task_id": "62e60ecfd76274f8a4026d6a", "original_prompt": "def protocol_handlers(cls, protocol_version=None):\n\t\"\"\"\n\tDifferent forms of Bolt protocol handlers are returned based on the value of protocol_version.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef protocol_handlers(cls, protocol_version=None):\n    if protocol_version is None:\n        return cls.default_protocol_handler()\n    elif protocol_version == 1:\n        return cls.protocol_handler_v1()\n    elif protocol_version == 2:\n        return cls.protocol_handler_v2()\n    elif protocol_version == 3:\n        return cls.protocol_handler_v3()\n    else:\n        raise ValueError(\"Unsupported protocol version\")\n```"}}}
{"dataset": "coderEval", "task_id": "62e60e49d76274f8a4026d25", "original_prompt": "def unit_of_work(metadata=None, timeout=None):\n\t\"\"\"\n\tReturns a decorator with metadata and timeout attributes.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef unit_of_work(metadata=None, timeout=None):\n    def decorator(func):\n        func.metadata = metadata\n        func.timeout = timeout\n        return func\n    return decorator\n```"}}}
{"dataset": "coderEval", "task_id": "62e60e05d76274f8a4026cfd", "original_prompt": "def index(self, key):\n\t\"\"\"\n\tReturns the key in the form of int.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef index(self, key):\n    return int(key)\n```"}}}
{"dataset": "coderEval", "task_id": "62e60da4d76274f8a4026cf1", "original_prompt": "def values(self, *keys):\n\t\"\"\"\n\tReturns the key filtered by self.index in the form of a list.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef values(self, *keys):\n    return [self.index[key] for key in keys if key in self.index]\n```"}}}
{"dataset": "coderEval", "task_id": "62e60b10d76274f8a4026ccd", "original_prompt": "def data(self, *keys):\n\t\"\"\"\n\tReturns the keys processed by the transform method of the RecordExporter class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef data(self, *keys):\n    return [self.transform(key) for key in keys]\n```"}}}
{"dataset": "coderEval", "task_id": "62e6087bd76274f8a4026bfa", "original_prompt": "def pop_u16(self):\n\t\"\"\"\n\tRemove the last two elements in self.data and return\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef pop_u16(self):\n    return self.data.pop() << 8 | self.data.pop()\n```"}}}
{"dataset": "coderEval", "task_id": "62e6087ad76274f8a4026bf2", "original_prompt": "def discard(self, n=-1, qid=-1, dehydration_hooks=None,\n                hydration_hooks=None, **handlers):\n\t\"\"\"\n\tAppends a DISCARD message to the output queue.\n\n:param n: number of records to discard, default = -1 (ALL)\n:param qid: query ID to discard for, default = -1 (last query)\n:param dehydration_hooks:\n    Hooks to dehydrate types (dict from type (class) to dehydration\n    function). Dehydration functions receive the value and returns an\n    object of type understood by packstream.\n:param hydration_hooks:\n    Hooks to hydrate types (mapping from type (class) to\n    dehydration function). Dehydration functions receive the value of\n    type understood by packstream and are free to return anything.\n:param handlers: handler functions passed into the returned Response object\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef discard(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None, **handlers):\n    dehydration_hooks = dehydration_hooks or {}\n    hydration_hooks = hydration_hooks or {}\n    self.output_queue.append(('DISCARD', n, qid, dehydration_hooks, hydration_hooks, handlers))\n```"}}}
{"dataset": "coderEval", "task_id": "62e60879d76274f8a4026bec", "original_prompt": "def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n              db=None, imp_user=None, dehydration_hooks=None,\n              hydration_hooks=None, **handlers):\n\t\"\"\"\n\tAppends a BEGIN message to the output queue.\n\n:param mode: access mode for routing - \"READ\" or \"WRITE\" (default)\n:param bookmarks: iterable of bookmark values after which this transaction should begin\n:param metadata: custom metadata dictionary to attach to the transaction\n:param timeout: timeout for transaction execution (seconds)\n:param db: name of the database against which to begin the transaction\n    Requires Bolt 4.0+.\n:param imp_user: the user to impersonate\n    Requires Bolt 4.4+\n:param dehydration_hooks:\n    Hooks to dehydrate types (dict from type (class) to dehydration\n    function). Dehydration functions receive the value and returns an\n    object of type understood by packstream.\n:param hydration_hooks:\n    Hooks to hydrate types (mapping from type (class) to\n    dehydration function). Dehydration functions receive the value of\n    type understood by packstream and are free to return anything.\n:param handlers: handler functions passed into the returned Response object\n:return: Response object\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n          db=None, imp_user=None, dehydration_hooks=None,\n          hydration_hooks=None, **handlers):\n    self.output_queue.append({\n       'mode': mode,\n        'bookmarks': bookmarks,\n       'metadata': metadata,\n        'timeout': timeout,\n        'db': db,\n        'imp_user': imp_user,\n        'dehydration_hooks': dehydration_hooks,\n        'hydration_hooks': hydration_hooks,\n        **handlers\n    })\n    return Response()\n```"}}}
{"dataset": "coderEval", "task_id": "62e60723d76274f8a4026b75", "original_prompt": "def round_half_to_even(n):\n\t\"\"\"\n\tRound a floating-point number\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef round_half_to_even(n):\n    return round(n)\n```"}}}
{"dataset": "coderEval", "task_id": "62e60707d76274f8a4026b69", "original_prompt": "def point_type(name, fields, srid_map):\n\t\"\"\"\n\tDynamically Generating Point Class\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef point_type(name, fields, srid_map):\n    class Point:\n        def __init__(self, **kwargs):\n            for field in fields:\n                setattr(self, field, kwargs.get(field))\n            self.srid = srid_map.get(kwargs.get('srid', 'default'))\n\n        def __repr__(self):\n            field_values = ', '.join(f'{field}={getattr(self, field)}' for field in fields)\n            return f\"{name}({field_values}, srid={self.srid})\"\n\n    return Point\n```"}}}
{"dataset": "coderEval", "task_id": "62e5dc9ed76274f8a4026b5b", "original_prompt": "def deprecated(message):\n\t\"\"\"\n\tReturn a decorator function for deprecating functions and methods.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef deprecated(message):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            print(f\"Warning: {func.__name__} is deprecated. {message}\")\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n```"}}}
{"dataset": "coderEval", "task_id": "62e4fc3c85ea98643089041e", "original_prompt": "def _inline_r_setup(code: str) -> str:\n\t\"\"\"\n\tSome behaviour of R cannot be configured via env variables, but can\nonly be configured via R options once R has started. These are set here.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def _inline_r_setup(code: str) -> str:\n    return f\"{code}\\noptions(warn=2)\\noptions(stringsAsFactors=FALSE)\""}}}
{"dataset": "coderEval", "task_id": "62e4fbda85ea986430890405", "original_prompt": "def xargs(\n        cmd: tuple[str, ...],\n        varargs: Sequence[str],\n        *,\n        color: bool = False,\n        target_concurrency: int = 1,\n        _max_length: int = _get_platform_max_length(),\n        **kwargs:\n\t\"\"\"\n\tSimplified Implementation of Xargs in Linux\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nfrom typing import Sequence\nimport subprocess\nimport os\n\ndef _get_platform_max_length():\n    return os.sysconf('SC_ARG_MAX')\n\ndef xargs(\n        cmd: tuple[str,...],\n        varargs: Sequence[str],\n        *,\n        color: bool = False,\n        target_concurrency: int = 1,\n        _max_length: int = _get_platform_max_length(),\n        **kwargs):\n    command = list(cmd)\n    if color:\n        command.append('--color')\n    total_length = sum(len(arg) + 1 for arg in command)\n    batch = []\n    processes = []\n\n    for arg in varargs:\n        arg_length = len(arg) + 1\n        if total_length + arg_length > _max_length:\n            processes.append(subprocess.Popen(command + batch, **kwargs))\n            batch = []\n            total_length = sum(len(arg) + 1 for arg in command)\n        batch.append(arg)\n        total_length += arg_length\n\n    if batch:\n        processes.append(subprocess.Popen(command + batch, **kwargs))\n\n    for process in processes:\n        process.wait()\n```"}}}
{"dataset": "coderEval", "task_id": "62e4fbda85ea986430890403", "original_prompt": "def _shuffled(seq: Sequence[str]) -> list[str]:\n\t\"\"\"\n\tShuffle a given seq with the given FIXED_RANDOM_SEED\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport random\n\nFIXED_RANDOM_SEED = 42\n\ndef _shuffled(seq: Sequence[str]) -> list[str]:\n    random.seed(FIXED_RANDOM_SEED)\n    shuffled_list = list(seq)\n    random.shuffle(shuffled_list)\n    return shuffled_list\n```"}}}
{"dataset": "coderEval", "task_id": "62e4fb6585ea98643089032b", "original_prompt": "def parse_version(s: str) -> tuple[int, ...]:\n\t\"\"\"\n\tConverts a string concatenated by dot to a tuple consisting of integers.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def parse_version(s: str) -> tuple[int,...]:\n    return tuple(int(part) for part in s.split('.'))"}}}
{"dataset": "coderEval", "task_id": "62e4fb4d85ea9864308902e7", "original_prompt": "def normalize_cmd(cmd: tuple[str, ...]) -> tuple[str, ...]:\n\t\"\"\"\n\tComplement the full path to exe and return it in its original form\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport os\n\ndef normalize_cmd(cmd: tuple[str,...]) -> tuple[str,...]:\n    exe_path = cmd[0]\n    if not os.path.isabs(exe_path):\n        exe_path = shutil.which(exe_path) or exe_path\n    return (exe_path,) + cmd[1:]\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d27a48ba5a41d1c3f4c6", "original_prompt": "def cached(cache, key=hashkey, lock=None):\n\t\"\"\"\n\tReturns a decorator function that saves the results in the cache\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef cached(cache, key=hash, lock=None):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            k = key(*args, **kwargs)\n            if lock:\n                with lock:\n                    if k in cache:\n                        return cache[k]\n                    result = func(*args, **kwargs)\n                    cache[k] = result\n            else:\n                if k in cache:\n                    return cache[k]\n                result = func(*args, **kwargs)\n                cache[k] = result\n            return result\n        return wrapper\n    return decorator\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d24048ba5a41d1c3f49f", "original_prompt": "def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n\t\"\"\"\n\tDecorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Least Recently Used (LRU)\nalgorithm with a per-item time-to-live (TTL) value.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport time\nfrom functools import lru_cache, wraps\n\ndef ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n    def decorator(func):\n        cache = lru_cache(maxsize=maxsize, typed=typed)\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            key = args + tuple(kwargs.items())\n            result, timestamp = cache.get(key, (None, 0))\n            if timer() - timestamp > ttl:\n                result = func(*args, **kwargs)\n                cache[key] = (result, timer())\n            return result\n\n        return wrapper\n    return decorator\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d23b48ba5a41d1c3f49a", "original_prompt": "def mru_cache(maxsize=128, typed=False):\n\t\"\"\"\n\tDecorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Most Recently Used (MRU)\nalgorithm.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nfrom collections import OrderedDict\n\ndef mru_cache(maxsize=128, typed=False):\n    def decorator(func):\n        cache = OrderedDict()\n        key_typed = (typed,)\n\n        def wrapper(*args, **kwargs):\n            key = args + key_typed + tuple(kwargs.items())\n            if key in cache:\n                return cache[key]\n            result = func(*args, **kwargs)\n            if len(cache) >= maxsize:\n                cache.popitem(last=True)\n            cache[key] = result\n            return result\n\n        return wrapper\n\n    return decorator\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d23948ba5a41d1c3f498", "original_prompt": "def lru_cache(maxsize=128, typed=False):\n\t\"\"\"\n\tDecorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Least Recently Used (LRU)\nalgorithm.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nfrom functools import lru_cache as _lru_cache\n\ndef lru_cache(maxsize=128, typed=False):\n    return _lru_cache(maxsize=maxsize, typed=typed)\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d23748ba5a41d1c3f496", "original_prompt": "def lfu_cache(maxsize=128, typed=False):\n\t\"\"\"\n\tDecorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Least Frequently Used (LFU)\nalgorithm.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nfrom collections import defaultdict\n\ndef lfu_cache(maxsize=128, typed=False):\n    cache = {}\n    freq = defaultdict(int)\n    key_to_freq = {}\n\n    def wrapper(*args, **kwargs):\n        key = args if not typed else (args, tuple(sorted(kwargs.items())))\n        if key in cache:\n            freq[key] += 1\n            return cache[key]\n        result = func(*args, **kwargs)\n        if len(cache) >= maxsize:\n            lfu_key = min(cache, key=lambda k: (freq[k], key_to_freq[k]))\n            del cache[lfu_key]\n            del freq[lfu_key]\n            del key_to_freq[lfu_key]\n        cache[key] = result\n        freq[key] = 1\n        key_to_freq[key] = len(key_to_freq)\n        return result\n\n    def func(*args, **kwargs):\n        return wrapper(*args, **kwargs)\n\n    return wrapper\n```\n\nNote: The provided code snippet has a logical error as the `func` is defined inside the `wrapper` and not passed as an argument. Here's the corrected version:\n\n```python\nfrom collections import defaultdict\n\ndef lfu_cache(maxsize=128, typed=False):\n    cache = {}\n    freq = defaultdict(int)\n    key_to_freq = {}\n\n    def wrapper(func):\n        def inner(*args, **kwargs):\n            key = args if not typed else (args, tuple(sorted(kwargs.items())))\n            if key in cache:\n                freq[key] += 1\n                return cache[key]\n            result = func(*args, **kwargs)\n            if len(cache) >= maxsize:\n                lfu_key = min(cache, key=lambda k: (freq[k], key_to_freq[k]))\n                del cache[lfu_key]\n                del freq[lfu_key]\n                del key_to_freq[lfu_key]\n            cache[key] = result\n            freq[key] = 1\n            key_to_freq[key] = len(key_to_freq)\n            return result\n        return inner\n    return wrapper\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d22f48ba5a41d1c3f488", "original_prompt": "def popitem(self):\n\t\"\"\"\n\tRemove the value corresponding to the first inserted key and returns the key and value in tuple format.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef popitem(self):\n    if not self:\n        raise KeyError(\"popitem(): dictionary is empty\")\n    key = next(iter(self))\n    value = self.pop(key)\n    return key, value\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d22a48ba5a41d1c3f47e", "original_prompt": "def setdefault(self, key, default=None):\n\t\"\"\"\n\tIf a key exists in the class, the value corresponding to the key is returned. Otherwise, the value corresponding to the key is set to default.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef setdefault(self, key, default=None):\n    return self.__dict__.setdefault(key, default)\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d22948ba5a41d1c3f47c", "original_prompt": "def get(self, key, default=None):\n\t\"\"\"\n\tIf a key exists in the class, the value corresponding to the key is returned. Otherwise, default is returned.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef get(self, key, default=None):\n    return self.__dict__.get(key, default)\n```"}}}
{"dataset": "coderEval", "task_id": "62b8d22548ba5a41d1c3f472", "original_prompt": "def cachedmethod(cache, key=hashkey, lock=None):\n\t\"\"\"\n\tReturns a decorator function that can call a result in the cache.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef cachedmethod(cache, key=hashkey, lock=None):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            k = key(*args, **kwargs)\n            if lock:\n                with lock:\n                    if k not in cache:\n                        cache[k] = func(*args, **kwargs)\n                    return cache[k]\n            else:\n                if k not in cache:\n                    cache[k] = func(*args, **kwargs)\n                return cache[k]\n        return wrapper\n    return decorator\n```"}}}
{"dataset": "coderEval", "task_id": "62b8c517e0d34b282c18122e", "original_prompt": "def extostr(cls, e, max_level=30, max_path_level=5):\n\t\"\"\"\n\tFormat the exception as a string\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef extostr(cls, e, max_level=30, max_path_level=5):\n    if max_level <= 0:\n        return str(e)\n    exc_type = type(e).__name__\n    exc_message = str(e)\n    tb = e.__traceback__\n    frames = []\n    while tb and max_level > 0:\n        frame = tb.tb_frame\n        code = frame.f_code\n        filename = code.co_filename.split('/')[-max_path_level:]\n        lineno = tb.tb_lineno\n        funcname = code.co_name\n        frames.append(f\"{':'.join(filename)}:{lineno} in {funcname}\")\n        tb = tb.tb_next\n        max_level -= 1\n    return f\"{exc_type}: {exc_message}\\nTraceback (most recent call last):\\n\" + \"\\n\".join(f\"  File \\\"{frame}\\\"\" for frame in frames)\n```"}}}
{"dataset": "coderEval", "task_id": "62b8bbbfe0d34b282c181210", "original_prompt": "def append_text_to_file(file_name, text_buffer, encoding, overwrite=False):\n\t\"\"\"\n\tWrites the data in the text buffer to a file\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef append_text_to_file(file_name, text_buffer, encoding, overwrite=False):\n    mode = 'w' if overwrite else 'a'\n    with open(file_name, mode, encoding=encoding) as file:\n        file.write(text_buffer)\n```"}}}
{"dataset": "coderEval", "task_id": "62b8bbbfe0d34b282c18120f", "original_prompt": "def file_to_textbuffer(file_name, encoding):\n\t\"\"\"\n\tLoad a file toward a text buffer\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef file_to_textbuffer(file_name, encoding):\n    with open(file_name, 'r', encoding=encoding) as file:\n        return file.read()\n```"}}}
{"dataset": "coderEval", "task_id": "62b8bbbce0d34b282c18120d", "original_prompt": "def is_file_exist(file_name):\n\t\"\"\"\n\tCheck whether file_name is an existing file.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport os\n\ndef is_file_exist(file_name):\n    return os.path.isfile(file_name)\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b99de0d34b282c1811f8", "original_prompt": "def _reset_logging(cls):\n\t\"\"\"\n\tReset the logging system\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _reset_logging(cls):\n    import logging\n    logging.shutdown()\n    logging.root.manager.loggerDict.clear()\n    logging.basicConfig(level=logging.NOTSET)\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b59feb7e40a82d2d1291", "original_prompt": "def _getTargetClass(self):\n\t\"\"\"\n\tDefine this to return the implementation in use,\nwithout the 'Py' or 'Fallback' suffix.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _getTargetClass(self):\n    return self.__class__.__name__.rstrip('PyFallback')\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b590eb7e40a82d2d1275", "original_prompt": "def _legacy_mergeOrderings(orderings):\n\t\"\"\"\n\tCombine multiple lists in the sequence of occurrence into a list with no duplicate elements.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def _legacy_mergeOrderings(orderings):\n    seen = set()\n    merged = []\n    for ordering in orderings:\n        for item in ordering:\n            if item not in seen:\n                seen.add(item)\n                merged.append(item)\n    return merged"}}}
{"dataset": "coderEval", "task_id": "62b8b58deb7e40a82d2d1269", "original_prompt": "def directlyProvidedBy(object):\n\t\"\"\"\n\tReturn the interfaces directly provided by the given object\n\nThe value returned is an `~zope.interface.interfaces.IDeclaration`.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nfrom zope.interface import providedBy\n\ndef directlyProvidedBy(obj):\n    return providedBy(obj).flattened()\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b559eb7e40a82d2d11f8", "original_prompt": "def minimalBases(classes):\n\t\"\"\"\n\tReturns all classes without subclasses as a list.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef minimalBases(classes):\n    return [cls for cls in classes if not any(issubclass(sub, cls) for sub in classes if sub is not cls)]\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b4b9eb7e40a82d2d1134", "original_prompt": "def namesAndDescriptions(self, all=False):\n\t\"\"\"\n\tReturns the name and description of the current class attribute.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef namesAndDescriptions(self, all=False):\n    if all:\n        return {attr: getattr(self, attr) for attr in dir(self) if not callable(getattr(self, attr)) and not attr.startswith('__')}\n    return {attr: getattr(self, attr) for attr in self.__dict__}\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b416eb7e40a82d2d1129", "original_prompt": "def names(self, all=False):\n\t\"\"\"\n\tReturn the attribute names of current class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef names(self, all=False):\n    return [attr for attr in dir(self) if not callable(getattr(self, attr)) and not attr.startswith('__')] if not all else dir(self)\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b3d6eb7e40a82d2d111c", "original_prompt": "def _normalizeargs(sequence, output=None):\n\t\"\"\"\n\tNormalize declaration arguments\n\nNormalization arguments might contain Declarions, tuples, or single\ninterfaces.\n\nAnything but individial interfaces or implements specs will be expanded.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _normalizeargs(sequence, output=None):\n    if output is None:\n        output = []\n    for item in sequence:\n        if isinstance(item, tuple):\n            _normalizeargs(item, output)\n        else:\n            output.append(item)\n    return output\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b3d5eb7e40a82d2d1110", "original_prompt": "def _c_optimizations_available():\n\t\"\"\"\n\tIf available, return the C optimization module, otherwise a false value.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _c_optimizations_available():\n    try:\n        import c_optimizations\n        return c_optimizations\n    except ImportError:\n        return False\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b3d4eb7e40a82d2d110f", "original_prompt": "def _should_attempt_c_optimizations():\n\t\"\"\"\n\tReturn a true value if we use the C optimizations.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _should_attempt_c_optimizations():\n    return True\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b3d4eb7e40a82d2d110e", "original_prompt": "def _c_optimizations_ignored():\n\t\"\"\"\n\tReturn True if get \"PURE_PYTHON\" environ is not none and not 0, else return False\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport os\n\ndef _c_optimizations_ignored():\n    return os.getenv(\"PURE_PYTHON\") not in (None, \"0\")\n```"}}}
{"dataset": "coderEval", "task_id": "62b8b3d4eb7e40a82d2d110d", "original_prompt": "def _c_optimizations_required():\n\t\"\"\"\n\tReturn a true value if the C optimizations are required.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _c_optimizations_required():\n    return True\n```"}}}
{"dataset": "coderEval", "task_id": "62b87b989a0c4fa8b80b35ee", "original_prompt": "def reset(self):\n\t\"\"\"\n\tCurrent context is reset to an empty dict, bins of the class are reinitialized with the *initial_value* or with *make_bins()*.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef reset(self):\n    self.context = {}\n    if hasattr(self, 'initial_value'):\n        self.bins = {key: self.initial_value for key in self.make_bins()}\n    else:\n        self.bins = {key: None for key in self.make_bins()}\n```"}}}
{"dataset": "coderEval", "task_id": "62b87b859a0c4fa8b80b35d7", "original_prompt": "def to_csv(self, separator=\",\", header=None):\n\t\"\"\"\n\t.. deprecated:: 0.5 in Lena 0.5 to_csv is not used.\n      Iterables are converted to tables.\n\nConvert graph's points to CSV.\n\n*separator* delimits values, the default is comma.\n\n*header*, if not ``None``, is the first string of the output\n(new line is added automatically).\n\nSince a graph can be multidimensional,\nfor each point first its coordinate is converted to string\n(separated by *separator*), then each part of its value.\n\nTo convert :class:`Graph` to CSV inside a Lena sequence,\nuse :class:`lena.output.ToCSV`.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef to_csv(self, separator=\",\", header=None):\n    rows = []\n    if header is not None:\n        rows.append(header)\n    for point in self.points:\n        coordinates = separator.join(map(str, point.coordinates))\n        values = separator.join(map(str, point.values))\n        rows.append(f\"{coordinates}{separator}{values}\")\n    return \"\\n\".join(rows)\n```"}}}
{"dataset": "coderEval", "task_id": "62b87b839a0c4fa8b80b35cb", "original_prompt": "def _get_err_indices(self, coord_name):\n\t\"\"\"\n\tFind all error indexes corresponding to coord_name.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _get_err_indices(self, coord_name):\n    return [index for index, name in enumerate(self.coordinate_names) if name == coord_name]\n```"}}}
{"dataset": "coderEval", "task_id": "62b87b7e9a0c4fa8b80b35bc", "original_prompt": "def _update_context(self, context):\n\t\"\"\"\n\tUpdate *context* with the properties of this graph.\n\n*context.error* is appended with indices of errors.\nExample subcontext for a graph with fields \"E,t,error_E_low\":\n{\"error\": {\"x_low\": {\"index\": 2}}}.\nNote that error names are called \"x\", \"y\" and \"z\"\n(this corresponds to first three coordinates,\nif they are present), which allows to simplify plotting.\nExisting values are not removed\nfrom *context.value* and its subcontexts.\n\nCalled on \"destruction\" of the graph (for example,\nin :class:`.ToCSV`). By destruction we mean conversion\nto another structure (like text) in the flow.\nThe graph object is not really destroyed in this process.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def _update_context(self, context):\n    if hasattr(self, 'E'):\n        context.setdefault('value', {})['E'] = self.E\n    if hasattr(self, 't'):\n        context.setdefault('value', {})['t'] = self.t\n    if hasattr(self, 'error_E_low'):\n        context.setdefault('error', {})['x_low'] = {'index': 2}"}}}
{"dataset": "coderEval", "task_id": "62b87b4f9a0c4fa8b80b3580", "original_prompt": "def integral(bins, edges):\n\t\"\"\"\n\tCalculate the area of the overall graph.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef integral(bins, edges):\n    return sum(b * (e2 - e1) for b, (e1, e2) in zip(bins, zip(edges, edges[1:])))\n```"}}}
{"dataset": "coderEval", "task_id": "62b87b199a0c4fa8b80b354e", "original_prompt": "def is_fill_request_seq(seq):\n\t\"\"\"\n\tCheck whether seq can be converted to FillRequestSeq and bool is returned.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def is_fill_request_seq(seq):\n    if not isinstance(seq, (list, tuple)):\n        return False\n    return all(isinstance(item, dict) and 'fill' in item for item in seq)"}}}
{"dataset": "coderEval", "task_id": "62b87b099a0c4fa8b80b3538", "original_prompt": "def is_fill_request_el(obj):\n\t\"\"\"\n\tCheck whether the obj class has the fill and request attributes.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef is_fill_request_el(obj):\n    return hasattr(obj, 'fill') and hasattr(obj,'request')\n```"}}}
{"dataset": "coderEval", "task_id": "62b87af99a0c4fa8b80b3524", "original_prompt": "def is_run_el(obj):\n\t\"\"\"\n\tCheck whether the obj class has the run method.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef is_run_el(obj):\n    return hasattr(obj, 'run')\n```"}}}
{"dataset": "coderEval", "task_id": "62b87af69a0c4fa8b80b351a", "original_prompt": "def is_fill_compute_el(obj):\n\t\"\"\"\n\tCheck whether the obj class has the fill and compute methods.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef is_fill_compute_el(obj):\n    return hasattr(obj, 'fill') and callable(getattr(obj, 'fill')) and \\\n           hasattr(obj, 'compute') and callable(getattr(obj, 'compute'))\n```"}}}
{"dataset": "coderEval", "task_id": "62b87af19a0c4fa8b80b34f7", "original_prompt": "def difference(d1, d2, level=-1):\n\t\"\"\"\n\tReturn a dictionary with items from d1 not contained in d2.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def difference(d1, d2, level=-1):\n    result = {}\n    for key in d1:\n        if key not in d2:\n            result[key] = d1[key]\n        elif isinstance(d1[key], dict) and isinstance(d2[key], dict) and level!= 0:\n            sub_diff = difference(d1[key], d2[key], level - 1)\n            if sub_diff:\n                result[key] = sub_diff\n    return result"}}}
{"dataset": "coderEval", "task_id": "62b87af09a0c4fa8b80b34f1", "original_prompt": "def fill(self, coord, weight=1):\n\t\"\"\"\n\tFill histogram at *coord* with the given *weight*.\n\nCoordinates outside the histogram edges are ignored.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef fill(self, coord, weight=1):\n    if self._is_within_bounds(coord):\n        self.histogram[tuple(coord)] += weight\n\ndef _is_within_bounds(self, coord):\n    return all(0 <= c < s for c, s in zip(coord, self.shape))\n```"}}}
{"dataset": "coderEval", "task_id": "62b86aa3b4d922cb0e688d36", "original_prompt": "def _validate_labels(labels):\n\t\"\"\"\n\tCheck that keys and values in the given labels by validate_key() and validate_value().\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _validate_labels(labels):\n    for key, value in labels.items():\n        validate_key(key)\n        validate_value(value)\n```"}}}
{"dataset": "coderEval", "task_id": "62b86a9eb4d922cb0e688d25", "original_prompt": "def _get_resource_name_regex():\n\t\"\"\"\n\tReturn the regular expressions that are used to validate the name of the Krake resources\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport re\n\ndef _get_resource_name_regex():\n    return re.compile(r'^[a-z0-9]([-a-z0-9]*[a-z0-9])?$')\n```"}}}
{"dataset": "coderEval", "task_id": "62b86a4fb4d922cb0e688cf8", "original_prompt": "def validate_value(value):\n\t\"\"\"\n\tValidate the given value against the corresponding regular expression.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport re\n\ndef validate_value(value):\n    pattern = r'^\\d{3}-\\d{2}-\\d{4}$'  # Example pattern: Social Security Number format\n    return bool(re.match(pattern, value))\n```"}}}
{"dataset": "coderEval", "task_id": "62b86a4fb4d922cb0e688cf7", "original_prompt": "def validate_key(key):\n\t\"\"\"\n\tValidate the given key against the corresponding regular expression.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport re\n\ndef validate_key(key):\n    pattern = r'^[a-zA-Z0-9_-]{3,20}$'\n    return bool(re.match(pattern, key))\n```"}}}
{"dataset": "coderEval", "task_id": "62b86a01b4d922cb0e688ccc", "original_prompt": "def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n\t\"\"\"\n\tThe values corresponding to different keys in the new dict are generated based on the value type (such as dict and list) in the manifest_dict file. Then new dictionary is returned.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef generate_default_observer_schema_dict(manifest_dict, first_level=False):\n    result = {}\n    for key, value in manifest_dict.items():\n        if isinstance(value, dict):\n            result[key] = generate_default_observer_schema_dict(value)\n        elif isinstance(value, list):\n            if value:\n                result[key] = [generate_default_observer_schema_dict(item) if isinstance(item, dict) else item for item in value]\n            else:\n                result[key] = []\n        else:\n            result[key] = value\n    return result\n```"}}}
{"dataset": "coderEval", "task_id": "62b869ebb4d922cb0e688cc6", "original_prompt": "def update_last_applied_manifest_list_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n\t\"\"\"\n\tTogether with :func:``update_last_applied_manifest_dict_from_resp``, this\nfunction is called recursively to update a partial ``last_applied_manifest``\nfrom a partial Kubernetes response\n\nArgs:\n    last_applied_manifest (list): partial ``last_applied_manifest`` being\n        updated\n    observer_schema (list): partial ``observer_schema``\n    response (list): partial response from the Kubernetes API.\n\nThis function go through all observed fields, and initialized their value in\nlast_applied_manifest if they are not yet present\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def update_last_applied_manifest_list_from_resp(last_applied_manifest, observer_schema, response):\n    for schema_item, resp_item in zip(observer_schema, response):\n        if isinstance(schema_item, dict) and isinstance(resp_item, dict):\n            update_last_applied_manifest_dict_from_resp(last_applied_manifest[observer_schema.index(schema_item)], schema_item, resp_item)\n        elif isinstance(schema_item, list) and isinstance(resp_item, list):\n            update_last_applied_manifest_list_from_resp(last_applied_manifest[observer_schema.index(schema_item)], schema_item, resp_item)\n        else:\n            if observer_schema.index(schema_item) >= len(last_applied_manifest):\n                last_applied_manifest.append(None)\n            if last_applied_manifest[observer_schema.index(schema_item)] is None:\n                last_applied_manifest[observer_schema.index(schema_item)] = resp_item"}}}
{"dataset": "coderEval", "task_id": "62b869eab4d922cb0e688cc5", "original_prompt": "def update_last_applied_manifest_dict_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n\t\"\"\"\n\tTogether with :func:``update_last_applied_manifest_list_from_resp``, this\nfunction is called recursively to update a partial ``last_applied_manifest``\nfrom a partial Kubernetes response\n\nArgs:\n    last_applied_manifest (dict): partial ``last_applied_manifest`` being\n        updated\n    observer_schema (dict): partial ``observer_schema``\n    response (dict): partial response from the Kubernetes API.\n\nRaises:\n    KeyError: If the observed field is not present in the Kubernetes response\n\nThis function go through all observed fields, and initialized their value in\nlast_applied_manifest if they are not yet present\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef update_last_applied_manifest_dict_from_resp(last_applied_manifest, observer_schema, response):\n    for key, schema in observer_schema.items():\n        if key in response:\n            if isinstance(schema, dict) and isinstance(response[key], dict):\n                last_applied_manifest.setdefault(key, {})\n                update_last_applied_manifest_dict_from_resp(last_applied_manifest[key], schema, response[key])\n            else:\n                last_applied_manifest[key] = response[key]\n        else:\n            raise KeyError(f\"Observed field {key} not present in the Kubernetes response\")\n```"}}}
{"dataset": "coderEval", "task_id": "62b869eab4d922cb0e688cbf", "original_prompt": "def generate_default_observer_schema(app):\n\t\"\"\"\n\tGenerate the default observer schema for each Kubernetes resource present in ``spec.manifest`` for which a custom observer schema hasn't been specified.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def generate_default_observer_schema(app):\n    for resource in app.spec.manifest:\n        if resource not in app.custom_observer_schemas:\n            app.default_observer_schemas[resource] = {\n                'type': 'object',\n                'properties': {\n                   'status': {'type':'string'},\n                   'ready': {'type': 'boolean'}\n                },\n               'required': ['status','ready']\n            }"}}}
{"dataset": "coderEval", "task_id": "62b43427903eeb48555d3ea5", "original_prompt": "def format(\n\t\tself,\n\t\tsql: AnyStr,\n\t\tparams: Union[Dict[Union[str, int], Any], Sequence[Any]],\n\t) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:\n\t\"\"\"\n\tConvert sql using self._converter.convert\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef format(self, sql: AnyStr, params: Union[Dict[Union[str, int], Any], Sequence[Any]]) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:\n    return self._converter.convert(sql, params)\n```"}}}
{"dataset": "coderEval", "task_id": "62b43428903eeb48555d3eaa", "original_prompt": "def formatmany(\n\t\tself,\n\t\tsql: AnyStr,\n\t\tmany_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n\t) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n\t\"\"\"\n\tConvert sql using self._converter.convert_many\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef formatmany(\n        self,\n        sql: AnyStr,\n        many_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n    return self._converter.convert_many(sql, many_params)\n```"}}}
{"dataset": "coderEval", "task_id": "62b45df05108cfac7f2109ce", "original_prompt": "def validate(self, path):\n\t\"\"\"\n\tReturns True if OCFL object at path or pyfs root, False otherwise.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef validate(self, path):\n    try:\n        root = self.fs.opendir(path)\n        return 'inventory.json' in root.listdir() and '0=ocfl_object_1.0' in root.listdir()\n    except (FileNotFoundError, PermissionError):\n        return False\n```"}}}
{"dataset": "coderEval", "task_id": "62b45df15108cfac7f2109dc", "original_prompt": "def status_str(self, prefix=''):\n\t\"\"\"\n\tReturn a string with visiting the sorted self.messages list, each visit add prefix and the element in the sorted self.messages list.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef status_str(self, prefix=''):\n    return ''.join(f\"{prefix}{message}\" for message in sorted(self.messages))\n```"}}}
{"dataset": "coderEval", "task_id": "62b45df15108cfac7f2109dd", "original_prompt": "def status_str(self, prefix=''):\n\t\"\"\"\n\tReturn string representation with self.log.status_str, with optional prefix.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef status_str(self, prefix=''):\n    return f\"{prefix}{self.log.status_str}\"\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e135108cfac7f2109f4", "original_prompt": "def is_valid(self, identifier):\n\t\"\"\"\n\tReturn True if identifier is valid. In this base implementation, always return True.  (D)\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef is_valid(self, identifier):\n    return True\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e145108cfac7f210a07", "original_prompt": "def validate(self, inventory, extract_spec_version=False):\n\t\"\"\"\n\tValidate a given inventory. If extract_spec_version is True then will look at the type value to determine the specification version. In the case that there is no type value or it isn't valid, then other tests will be based on the version given in self.spec_version. (D)\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef validate(self, inventory, extract_spec_version=False):\n    if extract_spec_version:\n        spec_version = inventory.get('type', self.spec_version)\n    else:\n        spec_version = self.spec_version\n\n    # Add validation logic here based on spec_version\n    # Example:\n    # if spec_version == '1.0':\n    #     return self._validate_v1_0(inventory)\n    # elif spec_version == '2.0':\n    #     return self._validate_v2_0(inventory)\n    # else:\n    #     raise ValueError(f\"Unsupported specification version: {spec_version}\")\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e145108cfac7f210a09", "original_prompt": "def check_digests_present_and_used(self, manifest_files, digests_used):\n\t\"\"\"\n\tCheck all digests in manifest that are needed are present and used. Return error() in the class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef check_digests_present_and_used(self, manifest_files, digests_used):\n    missing_digests = set(manifest_files) - set(digests_used)\n    if missing_digests:\n        return self.error()\n    return None\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e165108cfac7f210a16", "original_prompt": "def validate_as_prior_version(self, prior):\n\t\"\"\"\n\tCheck that prior is a valid prior version of the current inventory object. The input variable prior is also expected to be an InventoryValidator object and both self and prior inventories are assumed to have been checked for internal consistency. Return error() in the class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef validate_as_prior_version(self, prior):\n    if not isinstance(prior, InventoryValidator):\n        return self.error()\n    if prior.version >= self.version:\n        return self.error()\n    return None\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e165108cfac7f210a17", "original_prompt": "def get_logical_path_map(inventory, version):\n\t\"\"\"\n\tReturns the file paths of the states in the inventory in the dict type.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef get_logical_path_map(inventory, version):\n    return {state: f\"{inventory}/{version}/{state}.yaml\" for state in inventory}\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e175108cfac7f210a19", "original_prompt": "def validate_fixity(self, fixity, manifest_files):\n\t\"\"\"\n\tValidate fixity block in inventory. Check the structure of the fixity block and makes sure that only files listed in the manifest are referenced. Return error() in the class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef validate_fixity(self, fixity, manifest_files):\n    if not isinstance(fixity, dict) or 'files' not in fixity:\n        return self.error()\n    \n    for file_name in fixity['files']:\n        if file_name not in manifest_files:\n            return self.error()\n    \n    return True\n```"}}}
{"dataset": "coderEval", "task_id": "62b463153879012d19481498", "original_prompt": "def files_list(path):\n\t\"\"\"\n\tReturn the files in given path.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport os\n\ndef files_list(path):\n    return [f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))]\n```"}}}
{"dataset": "coderEval", "task_id": "62b463153879012d1948149a", "original_prompt": "def _group_files_by_xml_filename(source, xmls, files):\n\t\"\"\"\n\tGroups files by xmls and returns data in dict format.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _group_files_by_xml_filename(source, xmls, files):\n    grouped = {xml: [] for xml in xmls}\n    for file in files:\n        for xml in xmls:\n            if f\"{source}/{xml}\" in file:\n                grouped[xml].append(file)\n    return grouped\n```"}}}
{"dataset": "coderEval", "task_id": "62b463153879012d1948149b", "original_prompt": "def match_file_by_prefix(prefix, file_path):\n\t\"\"\"\n\tGiven a filepath, return true if the basename of the filepath is startswith the given prefix plus \"-\" or the given prefix plus \".\"\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef match_file_by_prefix(prefix, file_path):\n    import os\n    basename = os.path.basename(file_path)\n    return basename.startswith(f\"{prefix}-\") or basename.startswith(f\"{prefix}.\")\n```"}}}
{"dataset": "coderEval", "task_id": "62b463153879012d1948149c", "original_prompt": "def select_filenames_by_prefix(prefix, files):\n\t\"\"\"\n\tFor each file in files, return all files taht match the given prefix\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef select_filenames_by_prefix(prefix, files):\n    return [file for file in files if file.startswith(prefix)]\n```"}}}
{"dataset": "coderEval", "task_id": "62b463153879012d1948149d", "original_prompt": "def _explore_folder(folder):\n\t\"\"\"\n\tGroups files in the given group by using _group_files_by_xml_filename.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport os\n\ndef _explore_folder(folder):\n    files = os.listdir(folder)\n    grouped_files = _group_files_by_xml_filename(files)\n    return grouped_files\n\ndef _group_files_by_xml_filename(files):\n    file_dict = {}\n    for file in files:\n        if file.endswith('.xml'):\n            base_name = os.path.splitext(file)[0]\n            if base_name not in file_dict:\n                file_dict[base_name] = []\n            file_dict[base_name].append(file)\n    return file_dict\n```"}}}
{"dataset": "coderEval", "task_id": "62b463153879012d1948149f", "original_prompt": "def _eval_file(prefix, file_path):\n\t\"\"\"\n\tIdentify the type of the given file. Return None if the file do not match the given prefix or the type of the file is xml. Return dict with the key of component_id, file_path if the type of the file is \"pdf\", return dict with the key of component_id, file_path, ftype, file_path if the type of the file is not \"pdf\".\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _eval_file(prefix, file_path):\n    if not file_path.startswith(prefix):\n        return None\n\n    if file_path.endswith('.xml'):\n        return None\n\n    result = {'component_id': file_path, 'file_path': file_path}\n    if not file_path.endswith('.pdf'):\n        result['ftype'] = file_path\n    return result\n```"}}}
{"dataset": "coderEval", "task_id": "62b463153879012d194814a1", "original_prompt": "def add_rendition(self, lang, file_path):\n\t\"\"\"\n\tAssign the filepath invoke by filepath() in the class to \"lang\" in _renditions in the class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef add_rendition(self, lang, file_path):\n    self._renditions[lang] = self.filepath(file_path)\n```"}}}
{"dataset": "coderEval", "task_id": "62b463163879012d194814a2", "original_prompt": "def add_asset(self, basename, file_path):\n\t\"\"\"\n\tAssign the filepath invoke by filepath() in the class to \"basename\" in _assets in the class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef add_asset(self, basename, file_path):\n    self._assets[basename] = self.filepath(file_path)\n```"}}}
{"dataset": "coderEval", "task_id": "62b463163879012d194814a4", "original_prompt": "def _explore_zipfile(zip_path):\n\t\"\"\"\n\tGroups the given zip path by using _group_files_by_xml_filename.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport zipfile\nfrom collections import defaultdict\n\ndef _group_files_by_xml_filename(files):\n    grouped = defaultdict(list)\n    for file in files:\n        if file.endswith('.xml'):\n            base_name = file.rsplit('.', 1)[0]\n            grouped[base_name].append(file)\n    return grouped\n\ndef _explore_zipfile(zip_path):\n    with zipfile.ZipFile(zip_path, 'r') as z:\n        files = z.namelist()\n        return _group_files_by_xml_filename(files)\n```"}}}
{"dataset": "coderEval", "task_id": "62b463163879012d194814a6", "original_prompt": "def files_list_from_zipfile(zip_path):\n\t\"\"\"\n\tReturn the files in the given zip path.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport zipfile\n\ndef files_list_from_zipfile(zip_path):\n    with zipfile.ZipFile(zip_path, 'r') as z:\n        return z.namelist()\n```"}}}
{"dataset": "coderEval", "task_id": "62b4631b3879012d194814dd", "original_prompt": "def fix_namespace_prefix_w(content):\n\t\"\"\"\n\tReplace \"w:st=\" in content with \"w-st=\".\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef fix_namespace_prefix_w(content):\n    return content.replace(\"w:st=\", \"w-st=\")\n```"}}}
{"dataset": "coderEval", "task_id": "62b463283879012d1948153d", "original_prompt": "def match_pubdate(node, pubdate_xpaths):\n\t\"\"\"\n\tFor the given node, returns the first match in the pubdate_xpaths list.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef match_pubdate(node, pubdate_xpaths):\n    for xpath in pubdate_xpaths:\n        result = node.xpath(xpath)\n        if result:\n            return result[0]\n    return None\n```"}}}
{"dataset": "coderEval", "task_id": "62b463303879012d19481579", "original_prompt": "def _extract_number_and_supplment_from_issue_element(issue):\n\t\"\"\"\n\tReturn the possible values of number and sup from the contents of issue.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _extract_number_and_supplement_from_issue_element(issue):\n    import re\n    match = re.search(r'(\\d+)([a-zA-Z]*)', issue)\n    if match:\n        return match.group(1), match.group(2)\n    return None, None\n```"}}}
{"dataset": "coderEval", "task_id": "62b46740d2f69a53b466171a", "original_prompt": "def pretty(self, indent=0, debug=False):\n\t\"\"\"\n\tReturn a pretty formatted representation of self. obj = f\"'{self.obj}'\" if isinstance(self.obj, str) else repr(self.obj) return (\" \" * indent) + f\"{self.__class__.__name__}({debug_details}{obj})\"\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef pretty(self, indent=0, debug=False):\n    obj = f\"'{self.obj}'\" if isinstance(self.obj, str) else repr(self.obj)\n    debug_details = \"\" if not debug else f\"debug={debug}, \"\n    return (\" \" * indent) + f\"{self.__class__.__name__}({debug_details}{obj})\"\n```"}}}
{"dataset": "coderEval", "task_id": "62b46746d2f69a53b4661722", "original_prompt": "def absorb(self, args):\n\t\"\"\"\n\tGiven an `args` sequence of expressions, return a new list of expression applying absorption.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def absorb(self, args):\n    return [expr for expr in args if not any(expr == other or expr in other for other in args if expr!= other)]"}}}
{"dataset": "coderEval", "task_id": "62b86707b4d922cb0e688c2a", "original_prompt": "def on(self, hook):\n\t\"\"\"\n\tReturn a decorator function to add a new handler to the \"hook\" in the registry in the class.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef on(self, hook):\n    def decorator(handler):\n        if not hasattr(self, '_registry'):\n            self._registry = {}\n        if hook not in self._registry:\n            self._registry[hook] = []\n        self._registry[hook].append(handler)\n        return handler\n    return decorator\n```"}}}
{"dataset": "coderEval", "task_id": "62b86729b4d922cb0e688c2f", "original_prompt": "def base_config(user, etcd_host=\"localhost\", etcd_port=2379):\n\t\"\"\"\n\tCreates a configuration with some simple parameters, the key parameters contains \"tls\", \"authentication\", \"authorization\", \"etcd\", \"docs\", and \"log\".\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef base_config(user, etcd_host=\"localhost\", etcd_port=2379):\n    return {\n        \"tls\": False,\n        \"authentication\": False,\n        \"authorization\": False,\n        \"etcd\": {\n            \"host\": etcd_host,\n            \"port\": etcd_port\n        },\n        \"docs\": \"https://example.com/docs\",\n        \"log\": {\n            \"level\": \"info\",\n            \"file\": f\"/var/log/{user}.log\"\n        }\n    }\n```"}}}
{"dataset": "coderEval", "task_id": "62b8a4a4755ee91dce50a3d2", "original_prompt": "def _fromutc(self, dt):\n\t\"\"\"\n\tGiven a timezone datetime in a given timezone, calculates a timezone datetime in a new timezone.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef _fromutc(self, dt):\n    return self.localize(dt.replace(tzinfo=None))\n```"}}}
{"dataset": "coderEval", "task_id": "62b8982f755ee91dce50a241", "original_prompt": "def normalized(self):\n\t\"\"\"\n\tNormalize all units of time to integers.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef normalized(self):\n    return {\n       'seconds': int(self.seconds),\n       'minutes': int(self.minutes),\n        'hours': int(self.hours),\n        'days': int(self.days)\n    }\n```"}}}
{"dataset": "coderEval", "task_id": "62b89640755ee91dce50a114", "original_prompt": "def tzname_in_python2(namefunc):\n\t\"\"\"\n\tChange unicode output into bytestrings in Python 2\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def tzname_in_python2(namefunc):\n    return [str(name) if isinstance(name, unicode) else name for name in namefunc()]"}}}
{"dataset": "coderEval", "task_id": "62b87d24d292efb640a55670", "original_prompt": "def get_versions():\n\t\"\"\"\n\tObtains the version information. If the version information cannot be obtained, the default value is returned.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef get_versions():\n    try:\n        import pkg_resources\n        return pkg_resources.get_distribution('your_package_name').version\n    except Exception:\n        return 'default_version'\n```"}}}
{"dataset": "coderEval", "task_id": "62b87d24d292efb640a5566f", "original_prompt": "def render(pieces, style):\n\t\"\"\"\n\tInput pieces and a style, render the pieces to the corresponding style.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef render(pieces, style):\n    return [style(piece) for piece in pieces]\n```"}}}
{"dataset": "coderEval", "task_id": "62b87d24d292efb640a5566d", "original_prompt": "def plus_or_dot(pieces):\n\t\"\"\"\n\tReturn \".\" If the closet-tag of the pieces contains \"+\", otherwise, return \"+\".\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def plus_or_dot(pieces):\n    return \".\" if any(\"+\" in tag for tag in pieces) else \"+\""}}}
{"dataset": "coderEval", "task_id": "62b87d23d292efb640a5566b", "original_prompt": "def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n\t\"\"\"\n\tCall the given command(s).\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport subprocess\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    if not isinstance(commands, list):\n        commands = [commands]\n    \n    full_command = commands + args\n    stderr_option = subprocess.DEVNULL if hide_stderr else None\n    \n    result = subprocess.run(\n        full_command,\n        cwd=cwd,\n        env=env,\n        capture_output=True,\n        text=True,\n        stderr=stderr_option\n    )\n    \n    if verbose:\n        print(f\"Command: {' '.join(full_command)}\")\n        print(f\"Return Code: {result.returncode}\")\n        print(f\"Output: {result.stdout}\")\n        if not hide_stderr:\n            print(f\"Error: {result.stderr}\")\n    \n    return result\n```"}}}
{"dataset": "coderEval", "task_id": "62b87d23d292efb640a55668", "original_prompt": "def get_config():\n\t\"\"\"\n\tReturn a new VersioneerConfig() and set various attribute of it.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef get_config():\n    config = VersioneerConfig()\n    config.versionfile_source ='src/_version.py'\n    config.versionfile_build ='src/_version.py'\n    config.tag_prefix = ''\n    config.parentdir_prefix ='myproject-'\n    return config\n```"}}}
{"dataset": "coderEval", "task_id": "62b87d23d292efb640a55667", "original_prompt": "def register_vcs_handler(vcs, method):\n\t\"\"\"\n\tCreate decorator to mark a method as the handler of a object\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef register_vcs_handler(vcs, method):\n    def decorator(func):\n        setattr(func, f'_{vcs}_handler', method)\n        return func\n    return decorator\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e945108cfac7f210a4a", "original_prompt": "def validate_hierarchy(self, validate_objects=True, check_digests=True, show_warnings=False):\n\t\"\"\"\n\tValidate storage root hierarchy.\n\nReturns:\n    num_objects - number of objects checked\n    good_objects - number of objects checked that were found to be valid\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef validate_hierarchy(self, validate_objects=True, check_digests=True, show_warnings=False):\n    num_objects = 0\n    good_objects = 0\n\n    for obj in self.storage_root.iterate_objects():\n        num_objects += 1\n        if validate_objects and not obj.is_valid():\n            continue\n        if check_digests and not obj.check_digest():\n            continue\n        good_objects += 1\n\n    return num_objects, good_objects\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e515108cfac7f210a3c", "original_prompt": "def initialize(self):\n\t\"\"\"\n\tCreate and initialize a new OCFL storage root.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef initialize(self):\n    self.storage_root = {}\n    self.objects = []\n    self.version = \"1.0\"\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e2eb89c9fd354170232", "original_prompt": "def next_version(version):\n\t\"\"\"\n\tGiven next version identifier following existing pattern\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef next_version(version):\n    parts = list(map(int, version.split('.')))\n    parts[-1] += 1\n    return '.'.join(map(str, parts))\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e23e0d4551b0392c90a", "original_prompt": "def validate_version_inventories(self, version_dirs):\n\t\"\"\"\n\tEach version SHOULD have an inventory up to that point.\n\nAlso keep a record of any content digests different from those in the root inventory\nso that we can also check them when validating the content.\n\nversion_dirs is an array of version directory names and is assumed to be in\nversion sequence (1, 2, 3...).\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef validate_version_inventories(self, version_dirs):\n    differing_digests = set()\n    root_inventory = self.load_inventory(version_dirs[0])\n\n    for version_dir in version_dirs:\n        current_inventory = self.load_inventory(version_dir)\n        for item, digest in current_inventory.items():\n            if item not in root_inventory or root_inventory[item]!= digest:\n                differing_digests.add((item, digest))\n\n    return differing_digests\n\ndef load_inventory(self, version_dir):\n    # Placeholder for loading inventory logic\n    pass\n```"}}}
{"dataset": "coderEval", "task_id": "62b45e21e0d4551b0392c8ed", "original_prompt": "def find_path_type(path):\n\t\"\"\"\n\tReturn a string indicating the type of thing at the given path\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport os\n\ndef find_path_type(path):\n    if os.path.isfile(path):\n        return 'file'\n    elif os.path.isdir(path):\n        return 'directory'\n    elif os.path.islink(path):\n        return'symlink'\n    else:\n        return 'unknown'\n```"}}}
{"dataset": "coderEval", "task_id": "62b45b396decaeff903e1001", "original_prompt": "def amend_bzparams(self, params, bug_ids):\n\t\"\"\"\n\tAmend the Bugzilla params\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef amend_bzparams(self, params, bug_ids):\n    if not isinstance(bug_ids, list):\n        bug_ids = [bug_ids]\n    params['ids'] = ','.join(map(str, bug_ids))\n    return params\n```"}}}
{"dataset": "coderEval", "task_id": "62b4567ed7d32e5b55cc83d9", "original_prompt": "def deep_merge_nodes(nodes):\n\t\"\"\"\n\tMerge any node values corresponding to duplicate keys and return the result. If there are colliding keys with non-MappingNode values, the last of the values remains.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef deep_merge_nodes(nodes):\n    merged = {}\n    for node in nodes:\n        for key, value in node.items():\n            if key in merged and isinstance(merged[key], dict) and isinstance(value, dict):\n                merged[key] = deep_merge_nodes([merged[key], value])\n            else:\n                merged[key] = value\n    return merged\n```"}}}
{"dataset": "coderEval", "task_id": "62b4567ad7d32e5b55cc83af", "original_prompt": "def parse_arguments(*arguments):\n\t\"\"\"\n\tGiven command-line arguments with which this script was invoked, parse the arguments and return  them as an ArgumentParser instance\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport argparse\n\ndef parse_arguments(*arguments):\n    parser = argparse.ArgumentParser()\n    for arg in arguments:\n        parser.add_argument(arg)\n    return parser.parse_args()\n```"}}}
{"dataset": "coderEval", "task_id": "62b45679d7d32e5b55cc83a9", "original_prompt": "def parser_flags(parser):\n\t\"\"\"\n\tGiven an argparse.ArgumentParser instance, return its argument flags in a space-separated\nstring.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "def parser_flags(parser):\n    return''.join(action.option_strings for action in parser._actions if action.option_strings)"}}}
{"dataset": "coderEval", "task_id": "62b45665d7d32e5b55cc8365", "original_prompt": "def parse_arguments(*unparsed_arguments):\n\t\"\"\"\n\tParses parameters and returns them as dict maps\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef parse_arguments(*unparsed_arguments):\n    return dict(arg.split('=') for arg in unparsed_arguments if '=' in arg)\n```"}}}
{"dataset": "coderEval", "task_id": "62b45665d7d32e5b55cc8364", "original_prompt": "def parse_subparser_arguments(unparsed_arguments, subparsers):\n\t\"\"\"\n\tGiven a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\ninstance, give each requested action's subparser a shot at parsing all arguments. This allows\ncommon arguments like \"--repository\" to be shared across multiple subparsers.\n\nReturn the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\narguments, a list of remaining arguments not claimed by any subparser).\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef parse_subparser_arguments(unparsed_arguments, subparsers):\n    parsed_results = {}\n    remaining_arguments = list(unparsed_arguments)\n\n    for subparser_name, parser in subparsers.items():\n        try:\n            namespace, remaining = parser.parse_known_args(remaining_arguments)\n            if vars(namespace):\n                parsed_results[subparser_name] = namespace\n                remaining_arguments = remaining\n        except SystemExit:\n            continue\n\n    return parsed_results, remaining_arguments\n```"}}}
{"dataset": "coderEval", "task_id": "62b45665d7d32e5b55cc8363", "original_prompt": "def make_parsers():\n\t\"\"\"\n\tBuild a parser and its subparsers and return them as a tuple.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\nimport argparse\n\ndef make_parsers():\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers(dest='command')\n    return parser, subparsers\n```"}}}
{"dataset": "coderEval", "task_id": "62b438ba66fea644fe22cca2", "original_prompt": "def deep_merge_nodes(nodes):\n\t\"\"\"\n\tmerge any node values corresponding to duplicate keys and return the result. If there are colliding keys with non-MappingNode values, the last of the values remains.\n\t\"\"\"\n\t", "generations": {"Qwen/Qwen2.5-Coder-32B-Instruct": {"quality_focused": "```python\ndef deep_merge_nodes(nodes):\n    merged = {}\n    for node in nodes:\n        for key, value in node.items():\n            if isinstance(value, dict) and key in merged and isinstance(merged[key], dict):\n                merged[key] = deep_merge_nodes([merged[key], value])\n            else:\n                merged[key] = value\n    return merged\n```"}}}
